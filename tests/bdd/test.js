describe("pow", function() {



	describe("возводит x в степень n", function() {

		function makeTest(x) {
	    var expected = x * x * x;
		it("при возведении " + x + " в степень 3 результат: " + expected, function() {
			assert.equal(pow(x, 3), expected);
		});
		}

		for (var x = 1; x <= 5; x++) {
		makeTest(x);
		}
	});

	it("при возведении в отрицательную степень результат NaN", function() {
		assert(isNaN(pow(2, -1)), "pow(2, -1) не NaN");
	});

	it("при возведении в дробную степень результат NaN", function() {
		assert(isNaN(pow(2, 1.5)));
	});

	/*	it("возводит в n-ю степень", function() { // (1)
	assert.equal(pow(2, 3), 8); // Проверка, 2 в степени 3 должна выводить 8
	assert.equal(pow(3, 4), 81);
	});
*/
	/* Ещё можно сделать так (2)*/
	/*it("при возведении 2 в 3ю степень результат 8", function() {
	assert.equal(pow(2, 3), 8);
	});

	it("при возведении 3 в 4ю степень равен 81", function() {
	assert.equal(pow(3, 4), 81);
	});*/

	/*
	Их принципиальное различие в том, что если assert обнаруживает ошибку, то он тут же прекращает выполнение блока it. 
	Поэтому в первом варианте, если вдруг первый assert «провалился», то про результат второго мы никогда не узнаем.

	Таким образом, разделить эти тесты может быть полезно, чтобы мы получили больше информации о происходящем.

	Кроме того, есть ещё одно правило, которое желательно соблюдать.

	Один тест тестирует ровно одну вещь.

	Если мы явно видим, что тест включает в себя совершенно независимые проверки – лучше разбить его на два 
	более простых и наглядных.

	По этим причинам второй вариант здесь предпочтительнее.
	*/	
});